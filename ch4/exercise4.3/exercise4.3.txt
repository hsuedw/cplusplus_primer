In C++, there are four operators that do guarantee the order in which operands are evaluated. They are the logical AND (&&) operator, the logical OR (||) operator, the conditional (? :) operator and teh comma (,) operator. For other binary operators, the operand evalation order is not undefined.
In an expression, if the operands do not affect the same objects or perform IO, then the order in which the operands are evaluated is irrelevant. If any of these operands do affect the same objects, the the expression  is in error and has undefined behavior.For the sake of optimization and performance, this design is acceptable. However, the programmer must be careful about this issue.
When the programmer write compound expressions, two rules of thumb can be helpful:
1. When in doubt, parenthesize expressions to force the grouping that the logi of your program requires.
2. If you change the value of an operand, don't use that operand elsewhere in the same expression.
An important exception to the second rule occurs when the subexpression that changes the operand is itself the operand of another subexpression. For example, in *++iter, the increment changes the value of iter. The (now changed) value of iter is the operand to the dereference operator. In this (and similar) expressions, order of evaluation isn't an issue. The increment (i.e., the subexpression that changes the operand) must be evaluated before the dereference can be evaluated. Such usage poses no problems and is quite common.
